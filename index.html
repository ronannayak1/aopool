<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AO Fantasy Snake Draft</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <style>
    body { background-color: #0d1117; color: #e6edf3; font-family: 'Inter', sans-serif; }
    .sleeper-card { background-color: #161b22; border: 1px solid #30363d; }
    .sleeper-card-hover:hover { border-color: #58a6ff; }
    .accent-teal { color: #2de2e6; }
    .btn-main { background-color: #2de2e6; color: #0d1117; font-weight: 800; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.05em; }
    .btn-main:disabled { background-color: #30363d; color: #8b949e; cursor: not-allowed; }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #0d1117; }
    ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 10px; }
  </style>
</head>
<body class="antialiased">
  <nav class="border-b border-gray-800 p-4 sticky top-0 bg-slate-900 z-50 shadow-xl">
    <div class="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4">
      <div>
        <h1 class="text-xl font-800 tracking-tighter italic">
          AUSTRALIAN OPEN <span class="accent-teal">FANTASY DRAFT</span>
        </h1>
        <div class="text-xs text-gray-500 flex items-center gap-1">
          <span class="w-2 h-2 rounded-full bg-green-500"></span> Live Snake Draft (<span id="num-users-display">4</span> users, 32 players each)
        </div>
      </div>

      <div class="flex items-center gap-4">
        <a href="https://ausopen.com/draws" target="_blank" class="text-[10px] text-teal-400 hover:text-teal-200 uppercase font-bold tracking-widest border border-teal-800 px-2 py-1 rounded hover:bg-teal-900 transition">
            View Official Draw ↗
        </a>

        <div class="flex items-center gap-4">
          <div class="flex items-center gap-2">
            <label for="num-users-input" class="text-[10px] text-gray-400 uppercase font-bold tracking-widest">Users:</label>
            <input 
              type="number" 
              id="num-users-input" 
              min="2" 
              max="20" 
              value="4" 
              class="bg-gray-800 border border-gray-700 text-sm rounded-lg p-2 w-16 text-center focus:ring-teal-500 focus:border-teal-500"
              onchange="updateNumUsers(this.value)"
            />
          </div>
          <div id="auth-status-container" class="flex items-center gap-2">
            <button 
              id="sign-in-btn"
              onclick="loginAndSave()"
              class="text-[10px] text-teal-400 hover:text-teal-200 uppercase font-bold tracking-widest border border-teal-800 px-2 py-1 rounded hover:bg-teal-900 transition"
            >
              Sign In with Google
            </button>
            <div id="user-info" class="hidden text-[10px] text-gray-400">
              <span id="user-email"></span>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="max-w-7xl mx-auto mt-4 flex gap-1 border-t border-gray-800 pt-4">
      <button onclick="showPage('draft')" id="nav-draft" class="nav-btn px-4 py-2 text-sm font-bold uppercase tracking-widest bg-teal-500 text-slate-900 rounded-t">
        Draft
      </button>
      <button onclick="showPage('bracket')" id="nav-bracket" class="nav-btn px-4 py-2 text-sm font-bold uppercase tracking-widest text-gray-400 hover:text-teal-400 rounded-t transition">
        Bracket
      </button>
      <button onclick="showPage('teams')" id="nav-teams" class="nav-btn px-4 py-2 text-sm font-bold uppercase tracking-widest text-gray-400 hover:text-teal-400 rounded-t transition">
        Teams
      </button>
      <button onclick="showPage('trades')" id="nav-trades" class="nav-btn px-4 py-2 text-sm font-bold uppercase tracking-widest text-gray-400 hover:text-teal-400 rounded-t transition">
        Trades
      </button>
    </div>
  </nav>

  <!-- DRAFT PAGE -->
  <main id="page-draft" class="page-content max-w-7xl mx-auto p-4 grid grid-cols-1 lg:grid-cols-12 gap-6">
    <div class="lg:col-span-8 space-y-4">
      <div class="flex justify-between items-end mb-2 px-1">
        <div>
          <h2 class="text-sm font-bold uppercase tracking-widest text-gray-400">Players</h2>
          <div id="draft-status" class="text-xs text-teal-400 font-bold mt-1"></div>
        </div>
        <span id="player-count" class="text-xs text-gray-600"></span>
      </div>

      <div class="sleeper-card rounded-xl p-3">
        <div class="flex justify-between text-xs text-gray-500 mb-2">
          <span>Click "Draft" to assign player to the team currently on the clock.</span>
          <span id="snake-order-display">Snake order: 1 → 2 → 3 → 4 → 4 → 3 → 2 → 1</span>
        </div>
        <div id="player-list" class="grid grid-cols-1 md:grid-cols-2 gap-2 max-h-[70vh] overflow-y-auto"></div>
      </div>
    </div>
  </main>

  <!-- BRACKET PAGE -->
  <main id="page-bracket" class="page-content max-w-7xl mx-auto p-4 hidden">
    <div class="space-y-6">
      <div class="flex justify-between items-center">
        <h2 class="text-2xl font-bold">Tournament Bracket</h2>
        <select id="bracket-round-select" class="bg-gray-800 border border-gray-700 text-sm rounded-lg p-2 focus:ring-teal-500">
          <option value="1">Round 1</option>
          <option value="2">Round 2</option>
          <option value="3">Round 3</option>
          <option value="4">Round 4 (R16)</option>
          <option value="5">Round 5 (QF)</option>
          <option value="6">Round 6 (SF)</option>
          <option value="7">Round 7 (F)</option>
        </select>
      </div>

      <div class="sleeper-card rounded-xl p-4">
        <div class="text-[10px] text-gray-400 leading-relaxed mb-4">
          Select a round to view matchups. Click on a player to mark them as the winner of the match.
        </div>
        <div id="bracket-container" class="space-y-3"></div>
      </div>
    </div>
  </main>

  <!-- TEAMS PAGE -->
  <main id="page-teams" class="page-content max-w-7xl mx-auto p-4 hidden">
    <div class="space-y-6">
      <div>
        <h2 class="text-2xl font-bold mb-2">Teams & Scores</h2>
        <div class="text-[10px] text-gray-400 leading-relaxed mb-4">
          R1: 1 • R2: 1.5 • R3: 2.25 • R4: 3.375 • R5: 5.0625 • R6: 7.59375 • R7: 11.390625
        </div>
        <div id="team-name-editor" class="sleeper-card rounded-xl p-4 flex flex-col sm:flex-row gap-3 sm:items-end hidden">
          <div class="flex-1">
            <label for="team-name-input" class="block text-xs font-bold uppercase tracking-widest text-gray-400 mb-1">Team Name</label>
            <input
              id="team-name-input"
              type="text"
              class="w-full bg-gray-800 border border-gray-700 text-sm rounded-lg p-2 focus:ring-teal-500 focus:border-teal-500"
              placeholder="Enter team name"
            />
          </div>
          <button
            id="team-name-save-btn"
            onclick="saveTeamName()"
            class="btn-main px-4 py-2 rounded text-[11px] uppercase tracking-widest disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Save Name
          </button>
        </div>
        <div id="trade-mode-toggle" class="sleeper-card rounded-xl p-4 hidden">
          <div class="flex items-center justify-between">
            <div>
              <h3 class="text-sm font-bold uppercase tracking-widest text-teal-400 mb-1">Trade Mode</h3>
              <p class="text-[10px] text-gray-400">Select players from your team and another team to create a trade</p>
            </div>
            <button
              onclick="toggleTradeMode()"
              class="btn-main px-4 py-2 rounded text-[11px] uppercase tracking-widest"
            >
              Exit Trade Mode
            </button>
          </div>
          <div id="trade-selection-summary" class="mt-4 p-3 bg-gray-800 rounded border border-gray-700 hidden">
            <div class="text-xs text-gray-400 mb-2">Trade Summary:</div>
            <div class="flex gap-4 text-sm">
              <div>
                <span class="text-teal-400 font-bold">You Give:</span>
                <div id="my-trade-players" class="text-gray-300 mt-1"></div>
              </div>
              <div>
                <span class="text-teal-400 font-bold">You Receive:</span>
                <div id="their-trade-players" class="text-gray-300 mt-1"></div>
              </div>
            </div>
            <div class="mt-3 flex gap-2">
              <select id="trade-target-team" class="bg-gray-700 border border-gray-600 text-sm rounded-lg p-2 flex-1">
                <option value="">Select team to trade with...</option>
              </select>
              <button
                onclick="confirmTrade()"
                id="confirm-trade-btn"
                class="btn-main px-4 py-2 rounded text-[11px] uppercase tracking-widest disabled:opacity-50 disabled:cursor-not-allowed"
                disabled
              >
                Confirm Trade
              </button>
            </div>
          </div>
        </div>
      </div>

      <div id="teams-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
    </div>
  </main>

  <!-- TRADES PAGE -->
  <main id="page-trades" class="page-content max-w-7xl mx-auto p-4 hidden">
    <div class="space-y-6">
      <div>
        <h2 class="text-2xl font-bold mb-2">Trades</h2>
        <div class="text-[10px] text-gray-400 leading-relaxed mb-4">
          View and manage pending trades. Only the recipient can accept or deny trades.
        </div>
      </div>

      <div id="trades-container" class="space-y-4"></div>
    </div>
  </main>

  <script>
    // ==== FIREBASE CONFIG (REPLACE WITH YOUR OWN) ====
    const firebaseConfig = {
      apiKey: "AIzaSyCGDOKVi5-dlS_VClMEyKpl7_AQLrF3qr4",
      authDomain: "aopool.firebaseapp.com",
      databaseURL: "https://aopool-default-rtdb.firebaseio.com",
      projectId: "aopool",
      storageBucket: "aopool.firebasestorage.app",
      messagingSenderId: "1047771739023",
      appId: "1:1047771739023:web:603e3ced5b2932e49851fa"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth(); // Initialize Auth
    const provider = new firebase.auth.GoogleAuthProvider(); // Use Google to sign in

    // ==== SCORING TABLE ====
    const ROUND_POINTS = {
      1: 1, 2: 1.5, 3: 2.25, 4: 3.375, 5: 5.0625, 6: 7.59375, 7: 11.390625
    };

        // ==== INITIAL PLAYER LIST ====
    const basePlayers = [
      { id: 1, name: "C. Alcaraz", seed: 1, country: "spain", hyperlink: "https://ausopen.com/players/spain/carlos-alcaraz#!stats" },
      { id: 76, name: "A. Walton", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/adam-walton#!stats" },
      { id: 96, name: "Y. Hanfmann", seed: "", country: "germany", hyperlink: "https://ausopen.com/players/germany/yannick-hanfmann#!stats" },
      { id: 114, name: "Z. Svajda", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/zachary-svajda#!stats" },
      { id: 119, name: "M. Zheng", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/michael-zheng#!stats" },
      { id: 48, name: "S. Korda", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/sebastian-korda#!stats" },
      { id: 93, name: "T. Schoolkate", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/tristan-schoolkate#!stats" },
      { id: 32, name: "C. Moutet", seed: 32, country: "france", hyperlink: "https://ausopen.com/players/france/corentin-moutet#!stats" },
      { id: 19, name: "T. Paul", seed: 19, country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/tommy-paul#!stats" },
      { id: 51, name: "A. Kovacevic", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/aleksandar-kovacevic#!stats" },
      { id: 97, name: "T. Tirante", seed: "", country: "argentina", hyperlink: "https://ausopen.com/players/argentina/thiago-agustin-tirante#!stats" },
      { id: 84, name: "A. Vukic", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/aleksandar-vukic#!stats" },
      { id: 111, name: "N. Budkov Kjaer", seed: "", country: "norway", hyperlink: "https://ausopen.com/players/norway/nicolai-budkov-kjaer#!stats" },
      { id: 59, name: "R. Opelka", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/reilly-opelka#!stats" },
      { id: 79, name: "F. Misolic", seed: "", country: "austria", hyperlink: "https://ausopen.com/players/austria/filip-misolic#!stats" },
      { id: 14, name: "A. Davidovich Fokina", seed: 14, country: "spain", hyperlink: "https://ausopen.com/players/spain/alejandro-davidovich-fokina#!stats" },
      { id: 10, name: "A. Bublik", seed: 10, country: "kazakhstan", hyperlink: "https://ausopen.com/players/kazakhstan/alexander-bublik#!stats" },
      { id: 45, name: "J. Brooksby", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/jenson-brooksby#!stats" },
      { id: 44, name: "C. Ugo Carabelli", seed: "", country: "argentina", hyperlink: "https://ausopen.com/players/argentina/camilo-ugo-carabelli#!stats" },
      { id: 52, name: "M. Fucsovics", seed: "", country: "hungary", hyperlink: "https://ausopen.com/players/hungary/marton-fucsovics#!stats" },
      { id: 56, name: "M. Kecmanovic", seed: "", country: "serbia", hyperlink: "https://ausopen.com/players/serbia/miomir-kecmanovic#!stats" },
      { id: 35, name: "T. Etcheverry", seed: "", country: "argentina", hyperlink: "https://ausopen.com/players/argentina/tomas-martin-etcheverry#!stats" },
      { id: 123, name: "A. Fery", seed: "", country: "united-kingdom", hyperlink: "https://ausopen.com/players/united-kingdom/arthur-fery#!stats" },
      { id: 20, name: "F. Cobolli", seed: 20, country: "italy", hyperlink: "https://ausopen.com/players/italy/flavio-cobolli#!stats" },
      { id: 29, name: "F. Tiafoe", seed: 29, country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/frances-tiafoe#!stats" },
      { id: 124, name: "J. Kubler", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/jason-kubler#!stats" },
      { id: 105, name: "P. Kypson", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/patrick-kypson#!stats" },
      { id: 65, name: "F. Comesana", seed: "", country: "argentina", hyperlink: "https://ausopen.com/players/argentina/francisco-comesana#!stats" },
      { id: 71, name: "M. Navone", seed: "", country: "argentina", hyperlink: "https://ausopen.com/players/argentina/mariano-navone#!stats" },
      { id: 92, name: "H. Medjedovic", seed: "", country: "serbia", hyperlink: "https://ausopen.com/players/serbia/hamad-medjedovic#!stats" },
      { id: 53, name: "M. Berrettini", seed: "", country: "italy", hyperlink: "https://ausopen.com/players/italy/matteo-berrettini#!stats" },
      { id: 6, name: "A. De Minaur", seed: 6, country: "australia", hyperlink: "https://ausopen.com/players/australia/alex-de-minaur#!stats" },
      { id: 3, name: "A. Zverev", seed: 3, country: "germany", hyperlink: "https://ausopen.com/players/germany/alexander-zverev#!stats" },
      { id: 39, name: "G. Diallo", seed: "", country: "canada", hyperlink: "https://ausopen.com/players/canada/gabriel-diallo#!stats" },
      { id: 46, name: "A. Popyrin", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/alexei-popyrin#!stats" },
      { id: 47, name: "A. Muller", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/alexandre-muller#!stats" },
      { id: 85, name: "E. Nava", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/emilio-nava#!stats" },
      { id: 110, name: "K. Jacquet", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/kyrian-jacquet#!stats" },
      { id: 99, name: "B. Bonzi", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/benjamin-bonzi#!stats" },
      { id: 26, name: "C. Norrie", seed: 26, country: "united-kingdom", hyperlink: "https://ausopen.com/players/united-kingdom/cameron-norrie#!stats" },
      { id: 18, name: "F. Cerundolo", seed: 18, country: "argentina", hyperlink: "https://ausopen.com/players/argentina/francisco-cerundolo#!stats" },
      { id: 58, name: "Z. Zhizhen", seed: "", country: "china", hyperlink: "https://ausopen.com/players/china/zhizhen-zhang#!stats" },
      { id: 115, name: "L. Draxl", seed: "", country: "canada", hyperlink: "https://ausopen.com/players/canada/liam-draxl#!stats" },
      { id: 63, name: "D. Dzumhur", seed: "", country: "bosnia-and-herzegovina", hyperlink: "https://ausopen.com/players/bosnia-and-herzegovina/damir-dzumhur#!stats" },
      { id: 64, name: "A. Cazaux", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/arthur-cazaux#!stats" },
      { id: 117, name: "J. Faria", seed: "", country: "portugal", hyperlink: "https://ausopen.com/players/portugal/jaime-faria#!stats" },
      { id: 62, name: "M. Arnaldi", seed: "", country: "italy", hyperlink: "https://ausopen.com/players/italy/matteo-arnaldi#!stats" },
      { id: 13, name: "A. Rublev", seed: 13, country: "russia", hyperlink: "https://ausopen.com/players/russia/andrey-rublev#!stats" },
      { id: 70, name: "J. De Jong", seed: "", country: "netherlands", hyperlink: "https://ausopen.com/players/netherlands/jesper-de-jong#!stats" },
      { id: 106, name: "Q. Halys", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/quentin-halys#!stats" },
      { id: 78, name: "A. Tabilo", seed: "", country: "chile", hyperlink: "https://ausopen.com/players/chile/alejandro-tabilo#!stats" },
      { id: 55, name: "K. Majchrzak", seed: "", country: "poland", hyperlink: "https://ausopen.com/players/poland/kamil-majchrzak#!stats" },
      { id: 74, name: "J. Fearnley", seed: "", country: "united-kingdom", hyperlink: "https://ausopen.com/players/united-kingdom/jacob-fearnley#!stats" },
      { id: 49, name: "F. Marozsan", seed: "", country: "hungary", hyperlink: "https://ausopen.com/players/hungary/fabian-marozsan#!stats" },
      { id: 24, name: "A. Rinderknech", seed: 24, country: "france", hyperlink: "https://ausopen.com/players/france/arthur-rinderknech#!stats" },
      { id: 25, name: "L. Tien", seed: 25, country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/learner-tien#!stats" },
      { id: 57, name: "M. Giron", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/marcos-giron#!stats" },
      { id: 120, name: "E. Ymer", seed: "", country: "sweden", hyperlink: "https://ausopen.com/players/sweden/elias-ymer#!stats" },
      { id: 98, name: "A. Shevchenko", seed: "", country: "kazakhstan", hyperlink: "https://ausopen.com/players/kazakhstan/alexander-shevchenko#!stats" },
      { id: 80, name: "J. Cerundolo", seed: "", country: "argentina", hyperlink: "https://ausopen.com/players/argentina/juan-manuel-cerundolo#!stats" },
      { id: 102, name: "J. Thompson", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/jordan-thompson#!stats" },
      { id: 43, name: "N. Borges", seed: "", country: "portugal", hyperlink: "https://ausopen.com/players/portugal/nuno-borges#!stats" },
      { id: 7, name: "F. Auger-Aliassime", seed: 7, country: "canada", hyperlink: "https://ausopen.com/players/canada/felix-auger-aliassime#!stats" },
      { id: 5, name: "L. Musetti", seed: 5, country: "italy", hyperlink: "https://ausopen.com/players/italy/lorenzo-musetti#!stats" },
      { id: 69, name: "R. Collignon", seed: "", country: "belgium", hyperlink: "https://ausopen.com/players/belgium/raphael-collignon#!stats" },
      { id: 38, name: "L. Sonego", seed: "", country: "italy", hyperlink: "https://ausopen.com/players/italy/lorenzo-sonego#!stats" },
      { id: 94, name: "C. Taberner", seed: "", country: "spain", hyperlink: "https://ausopen.com/players/spain/carlos-taberner#!stats" },
      { id: 42, name: "G. Dimitrov", seed: "", country: "bulgaria", hyperlink: "https://ausopen.com/players/bulgaria/grigor-dimitrov#!stats" },
      { id: 33, name: "T. Machac", seed: "", country: "czech-republic", hyperlink: "https://ausopen.com/players/czech-republic/tomas-machac#!stats" },
      { id: 103, name: "S. Mochizuki", seed: "", country: "japan", hyperlink: "https://ausopen.com/players/japan/shintaro-mochizuki#!stats" },
      { id: 31, name: "S. Tsitsipas", seed: 31, country: "greece", hyperlink: "https://ausopen.com/players/greece/stefanos-tsitsipas#!stats" },
      { id: 17, name: "J. Lehecka", seed: 17, country: "czech-republic", hyperlink: "https://ausopen.com/players/czech-republic/jiri-lehecka#!stats" },
      { id: 125, name: "A. Gea", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/arthur-gea#!stats" },
      { id: 88, name: "L. Djere", seed: "", country: "serbia", hyperlink: "https://ausopen.com/players/serbia/laslo-djere#!stats" },
      { id: 112, name: "S. Wawrinka", seed: "", country: "switzerland", hyperlink: "https://ausopen.com/players/switzerland/stan-wawrinka#!stats" },
      { id: 95, name: "V. Kopriva", seed: "", country: "czech-republic", hyperlink: "https://ausopen.com/players/czech-republic/vit-kopriva#!stats" },
      { id: 81, name: "J. Struff", seed: "", country: "germany", hyperlink: "https://ausopen.com/players/germany/jan-lennard-struff#!stats" },
      { id: 54, name: "V. Royer", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/valentin-royer#!stats" },
      { id: 9, name: "T. Fritz", seed: 9, country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/taylor-fritz#!stats" },
      { id: 16, name: "J. Mensik", seed: 16, country: "czech-republic", hyperlink: "https://ausopen.com/players/czech-republic/jakub-mensik#!stats" },
      { id: 89, name: "P. Carreno Busta", seed: "", country: "spain", hyperlink: "https://ausopen.com/players/spain/pablo-carreno-busta#!stats" },
      { id: 128, name: "R. Sakamoto", seed: "", country: "japan", hyperlink: "https://ausopen.com/players/japan/rei-sakamoto#!stats" },
      { id: 116, name: "R. Jodar", seed: "", country: "spain", hyperlink: "https://ausopen.com/players/spain/rafael-jodar#!stats" },
      { id: 50, name: "H. Hurkacz", seed: "", country: "poland", hyperlink: "https://ausopen.com/players/poland/hubert-hurkacz#!stats" },
      { id: 40, name: "Z. Bergs", seed: "", country: "belgium", hyperlink: "https://ausopen.com/players/belgium/zizou-bergs#!stats" },
      { id: 75, name: "E. Quinn", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/ethan-quinn#!stats" },
      { id: 23, name: "T. Griekspoor", seed: 23, country: "netherlands", hyperlink: "https://ausopen.com/players/netherlands/tallon-griekspoor#!stats" },
      { id: 27, name: "B. Nakashima", seed: 27, country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/brandon-nakashima#!stats" },
      { id: 72, name: "B. Van De Zandschulp", seed: "", country: "netherlands", hyperlink: "https://ausopen.com/players/netherlands/botic-van-de-zandschulp#!stats" },
      { id: 126, name: "J. Shang", seed: "", country: "china", hyperlink: "https://ausopen.com/players/china/juncheng-shang#!stats" },
      { id: 87, name: "R. Bautista Agut", seed: "", country: "spain", hyperlink: "https://ausopen.com/players/spain/roberto-bautista-agut#!stats" },
      { id: 61, name: "T. Atmane", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/terence-atmane#!stats" },
      { id: 113, name: "F. Maestrelli", seed: "", country: "italy", hyperlink: "https://ausopen.com/players/italy/francesco-maestrelli#!stats" },
      { id: 68, name: "P. Martinez", seed: "", country: "spain", hyperlink: "https://ausopen.com/players/spain/pedro-martinez#!stats" },
      { id: 4, name: "N. Djokovic", seed: 4, country: "serbia", hyperlink: "https://ausopen.com/players/serbia/novak-djokovic#!stats" },
      { id: 8, name: "B. Shelton", seed: 8, country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/ben-shelton#!stats" },
      { id: 34, name: "U. Humbert", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/ugo-humbert#!stats" },
      { id: 122, name: "D. Sweeny", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/dane-sweeny#!stats" },
      { id: 101, name: "G. Monfils", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/gael-monfils#!stats" },
      { id: 66, name: "A. Mannarino", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/adrian-mannarino#!stats" },
      { id: 104, name: "R. Hijikata", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/rinky-hijikata#!stats" },
      { id: 121, name: "M. Damm", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/martin-damm#!stats" },
      { id: 30, name: "V. Vacherot", seed: 30, country: "monaco", hyperlink: "https://ausopen.com/players/monaco/valentin-vacherot#!stats" },
      { id: 21, name: "D. Shapovalov", seed: 21, country: "canada", hyperlink: "https://ausopen.com/players/canada/denis-shapovalov#!stats" },
      { id: 108, name: "Y. Bu", seed: "", country: "china", hyperlink: "https://ausopen.com/players/china/yunchaokete-bu#!stats" },
      { id: 41, name: "D. Altmaier", seed: "", country: "germany", hyperlink: "https://ausopen.com/players/germany/daniel-altmaier#!stats" },
      { id: 67, name: "M. Cilic", seed: "", country: "croatia", hyperlink: "https://ausopen.com/players/croatia/marin-cilic#!stats" },
      { id: 36, name: "J. Munar", seed: "", country: "spain", hyperlink: "https://ausopen.com/players/spain/jaume-munar#!stats" },
      { id: 90, name: "D. Svrcina", seed: "", country: "czech-republic", hyperlink: "https://ausopen.com/players/czech-republic/dalibor-svrcina#!stats" },
      { id: 73, name: "M. Bellucci", seed: "", country: "italy", hyperlink: "https://ausopen.com/players/italy/mattia-bellucci#!stats" },
      { id: 12, name: "C. Ruud", seed: 12, country: "norway", hyperlink: "https://ausopen.com/players/norway/casper-ruud#!stats" },
      { id: 15, name: "K. Khachanov", seed: 15, country: "russia", hyperlink: "https://ausopen.com/players/russia/karen-khachanov#!stats" },
      { id: 82, name: "A. Michelsen", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/alex-michelsen#!stats" },
      { id: 107, name: "C. O'Connell", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/christopher-oconnell#!stats" },
      { id: 127, name: "N. Basavareddy", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/nishesh-basavareddy#!stats" },
      { id: 60, name: "G. Mpetshi Perricard", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/giovanni-mpetshi-perricard#!stats" },
      { id: 37, name: "S. Baez", seed: "", country: "argentina", hyperlink: "https://ausopen.com/players/argentina/sebastian-baez#!stats" },
      { id: 77, name: "C. Garin", seed: "", country: "chile", hyperlink: "https://ausopen.com/players/chile/cristian-garin#!stats" },
      { id: 22, name: "L. Darderi", seed: 22, country: "italy", hyperlink: "https://ausopen.com/players/italy/luciano-darderi#!stats" },
      { id: 28, name: "J. Fonseca", seed: 28, country: "brazil", hyperlink: "https://ausopen.com/players/brazil/joao-fonseca#!stats" },
      { id: 86, name: "E. Spizzirri", seed: "", country: "united-states-america", hyperlink: "https://ausopen.com/players/united-states-america/eliot-spizzirri#!stats" },
      { id: 100, name: "L. Nardi", seed: "", country: "italy", hyperlink: "https://ausopen.com/players/italy/luca-nardi#!stats" },
      { id: 118, name: "W. Yibing", seed: "", country: "china", hyperlink: "https://ausopen.com/players/china/yibing-wu#!stats" },
      { id: 83, name: "J. Duckworth", seed: "", country: "australia", hyperlink: "https://ausopen.com/players/australia/james-duckworth#!stats" },
      { id: 109, name: "D. Prizmic", seed: "", country: "croatia", hyperlink: "https://ausopen.com/players/croatia/dino-prizmic#!stats" },
      { id: 91, name: "H. Gaston", seed: "", country: "france", hyperlink: "https://ausopen.com/players/france/hugo-gaston#!stats" },
      { id: 2, name: "J. Sinner", seed: 2, country: "italy", hyperlink: "https://ausopen.com/players/italy/jannik-sinner#!stats" }
    ];

    const initialPlayers = [...basePlayers].sort((a, b) => a.id - b.id).map(p => ({
      ...p,
      owner: null,
      totalWins: 0,
      points: 0,
      roundsWon: []
    }));

    // Draft settings
    let NUM_USERS = 4; // Can be changed via UI
    let USERS = Array.from({ length: NUM_USERS }, (_, i) => `User ${i + 1}`);
    const ROSTER_SIZE = 32; 
    const TOTAL_PICKS = initialPlayers.length; 

    // Email to User mapping
    const EMAIL_TO_USER = {
      'torinnayak@berkeley.edu': 'User 1',
      'ronannayak@gmail.com': 'User 2',
      'seemaslp@gmail.com': 'User 3',
      'nayakm@gmail.com': 'User 4'
    };

    // Current user (set via Google authentication email mapping)
    let currentUser = null;
    const numUsersInput = document.getElementById("num-users-input");
    const teamNameInput = document.getElementById("team-name-input");
    const teamNameSaveBtn = document.getElementById("team-name-save-btn");
    
    // Function to update number of users
    function updateNumUsers(newNum) {
      const num = parseInt(newNum, 10);
      if (isNaN(num) || num < 2 || num > 20) {
        alert("Number of users must be between 2 and 20");
        numUsersInput.value = NUM_USERS;
        return;
      }
      
      const oldNum = NUM_USERS;
      NUM_USERS = num;
      USERS = Array.from({ length: NUM_USERS }, (_, i) => `User ${i + 1}`);
      
      // Save to Firebase
      db.ref("/settings/numUsers").set(NUM_USERS);
      
      // Update Firebase users object - add new users if NUM_USERS increased
      if (num > oldNum) {
        db.ref("/users").once("value", snap => {
          const existingUsers = snap.val() || {};
          const usersObj = { ...existingUsers };
          
          // Add any new users that don't exist yet
          USERS.forEach(user => {
            if (!usersObj[user]) {
              usersObj[user] = { picks: [], score: 0 };
            }
          });
          
          db.ref("/users").set(usersObj);
        });
      }
      
      // Update all UI elements
      refreshUsersUI();
      
      // If current user no longer exists, reset to first user
      if (!USERS.includes(currentUser)) {
        currentUser = USERS[0];
        localStorage.setItem("ao_user", currentUser);
      }
    }
    
    // Function to refresh all user-related UI
    function refreshUsersUI() {
      
      
      // Update UI displays
      document.getElementById("num-users-display").textContent = NUM_USERS;
      numUsersInput.value = NUM_USERS;
      
      // Generate snake order display
      const forwardOrder = Array.from({ length: NUM_USERS }, (_, i) => i + 1).join(" → ");
      const reverseOrder = Array.from({ length: NUM_USERS }, (_, i) => NUM_USERS - i).join(" → ");
      document.getElementById("snake-order-display").textContent = `Snake order: ${forwardOrder} → ${reverseOrder}`;
    }
    
    // Populate user select dropdown initially
    refreshUsersUI();
    
    // Load NUM_USERS from Firebase on startup
    db.ref("/settings/numUsers").on("value", snap => {
      if (snap.exists()) {
        const savedNum = parseInt(snap.val(), 10);
        if (!isNaN(savedNum) && savedNum >= 2 && savedNum <= 20) {
          NUM_USERS = savedNum;
          USERS = Array.from({ length: NUM_USERS }, (_, i) => `User ${i + 1}`);
          refreshUsersUI();
        }
      }
    });
    
    // Make updateNumUsers available globally
    window.updateNumUsers = updateNumUsers;

    function getUserDraftOrder() {
      return USERS;
    }

    // Compute whose turn it is
    function computeCurrentDrafter(pickNumber) {
      const round = Math.floor(pickNumber / USERS.length);
      const indexInRound = pickNumber % USERS.length;
      const order = getUserDraftOrder();
      if (round % 2 === 0) {
        return order[indexInRound];
      } else {
        return order[USERS.length - 1 - indexInRound];
      }
    }

    // ===== Reset / Initialize Draft =====
    function resetDraft() {
      if (!confirm("Reset all teams, picks, and scoring for everyone?")) return;

      const usersObj = {};
      USERS.forEach(u => {
        usersObj[u] = { picks: [], score: 0 };
      });

      db.ref("/").set({
        players: initialPlayers,
        users: usersObj,
        draft: { currentPick: 0, finished: false }
      });
    }

    // ===== Draft a player (Commissioner Mode) =====
    // MODIFIED: This allows the click to work regardless of which user is selected in dropdown
    function draftPlayer(playerIndex) {
      db.ref("/").transaction(data => {
        if (!data) return data; // Wait for DB load
        
        // Initialize if empty
        if (!data.draft || !data.players) return data;

        const draft = data.draft;
        const players = data.players;
        const users = data.users;

        if (draft.finished) return data;

        const player = players[playerIndex];
        if (!player || player.owner) return data;

        // 1. Calculate who is supposed to draft right now
        const drafter = computeCurrentDrafter(draft.currentPick);

        if (drafter !== currentUser){
          return data;
        }


        // Check roster size
        if (users[drafter].picks && users[drafter].picks.length >= ROSTER_SIZE) {
          return data;
        }

        // Initialize array if missing
        if (!users[drafter].picks) users[drafter].picks = [];

        // Assign player
        players[playerIndex].owner = drafter;
        users[drafter].picks.push(player.id);

        draft.currentPick++;
        if (draft.currentPick >= TOTAL_PICKS) {
          draft.finished = true;
        }

        data.players = players;
        data.users = users;
        data.draft = draft;
        return data;
      });
    }

    // ===== Record a match win =====
    function recordWin() {
      const winnerSelect = document.getElementById("winner-select");
      const roundSelect = document.getElementById("round-select");

      const playerId = parseInt(winnerSelect.value, 10);
      const round = parseInt(roundSelect.value, 10);

      if (!playerId || !round) {
        alert("Select both player and round.");
        return;
      }

      const pointsToAdd = ROUND_POINTS[round] || 0;

      db.ref("/").transaction(data => {
        if (!data || !data.players || !data.users) return data;

        const players = data.players;
        const users = data.users;

        const pIndex = players.findIndex(p => p.id === playerId);
        if (pIndex === -1) return data;

        const player = players[pIndex];
        
        // Track which rounds this player has won
        if (!players[pIndex].roundsWon) players[pIndex].roundsWon = [];
        // Only add if not already recorded for this round (avoid duplicates)
        if (!players[pIndex].roundsWon.includes(round)) {
          players[pIndex].roundsWon.push(round);
          players[pIndex].roundsWon.sort((a, b) => a - b); // Keep sorted
        }
        
        // Update Player Stats
        players[pIndex].totalWins = (players[pIndex].totalWins || 0) + 1;
        players[pIndex].points = (players[pIndex].points || 0) + pointsToAdd;

        // Update Owner Stats (if owned)
        if (player.owner) {
          const owner = player.owner;
          users[owner].score = (users[owner].score || 0) + pointsToAdd;
        }

        data.players = players;
        data.users = users;
        return data;
      });

      roundSelect.value = "";
    }

    // ===== REALTIME RENDERING =====
    const playerListEl = document.getElementById("player-list");
    const draftStatusEl = document.getElementById("draft-status");
    const playerCountEl = document.getElementById("player-count");
    const winnerSelectEl = document.getElementById("winner-select");

    db.ref("/").on("value", snap => {
      const data = snap.val();
      
      // Handle empty DB state gracefully
      if (!data) {
        draftStatusEl.textContent = "Database empty. Click Reset Draft to start.";
        return; 
      }

      const players = data.players || [];
      const users = data.users || {};
      const draft = data.draft || { currentPick: 0, finished: false };
      const getDisplayName = (id) => (users[id]?.teamName || id || "");

      // DRAFT STATUS & CURRENT DRAFTER
      let drafter = "";
      if (draft.finished) {
        draftStatusEl.textContent = "Draft complete.";
      } else {
        drafter = computeCurrentDrafter(draft.currentPick);
        const picksDone = draft.currentPick;
        draftStatusEl.textContent = `ON THE CLOCK: ${drafter} (Pick ${picksDone + 1})`;
      }

// PLAYER LIST
      playerListEl.innerHTML = "";
      const undraftedCount = players.filter(p => !p.owner).length;
      playerCountEl.textContent = `${undraftedCount} left`;

      players.forEach((p, idx) => {
        const isOwned = !!p.owner;
        
        // CHANGED: Element type is now 'div' instead of 'button' to allow nested links
        const card = document.createElement("div");
        
        // Highlight logic
        const isTakenByMe = (p.owner === currentUser) && isOwned;
        const isDraftable = !isOwned && !draft.finished;

        // CHANGED: Added 'cursor-pointer' manually since it's no longer a button
        card.className =
          "sleeper-card sleeper-card-hover rounded-lg p-3 flex justify-between items-center text-left w-full relative " +
          (isOwned ? "opacity-50 " : "cursor-pointer ") + 
          (isTakenByMe ? "border-teal-500/50" : "");

        const ownerLabel = isOwned
          ? `<div class="text-[10px] text-teal-400 font-bold uppercase">${getDisplayName(p.owner)}</div>`
          : `<div class="text-[10px] text-gray-500 uppercase">Undrafted</div>`;
          
        const seedText = p.seed ? `<span class="text-[10px] text-gray-500 mr-2">[${p.seed}]</span>` : "";
        
        // Determine Button Text
        let btnClass = "btn-main px-2 py-1 rounded text-[10px]";
        
        if (!isDraftable) {
            btnClass = "hidden";
        }

        // CHANGED: Wrapped p.name in an <a> tag
        // Added onclick="event.stopPropagation()" so clicking the link DOES NOT draft the player
        card.innerHTML = `
          <div>
            <div class="text-sm font-bold">
                ${seedText}
                <a href="${p.hyperlink}" target="_blank" class="hover:text-teal-400 hover:underline z-10 relative" onclick="event.stopPropagation()">
                    ${p.name}
                </a>
            </div>
            <div class="flex gap-3 mt-1">
              ${ownerLabel}
              ${
                p.points && p.points > 0
                  ? `<div class="text-[10px] text-yellow-400">Pts: ${p.points.toFixed(3)}</div>`
                  : ""
              }
            </div>
          </div>
          <div class="text-right">
            <span class="${btnClass}">Draft</span>
          </div>
        `;

        // The card click still handles the drafting
        card.onclick = () => {
          if (isDraftable) draftPlayer(idx);
        };

        playerListEl.appendChild(card);
      });

      // WINNER SELECT OPTIONS
      winnerSelectEl.innerHTML = `<option value="">Select Player</option>`;
      players.forEach(p => {
        const label = p.seed ? `[${p.seed}] ${p.name}` : p.name;
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = label;
        winnerSelectEl.appendChild(opt);
      });

      // Note: User stats display removed - now shown on Teams page

      // Refresh other pages if they're currently visible
      const activePage = localStorage.getItem('ao_active_page') || 'draft';
      if (activePage === 'teams') {
        refreshTeams();
      }
      if (activePage === 'bracket') {
        refreshBracket();
      }
      if (activePage === 'trades') {
        refreshTrades();
      }
    });

    // ===== PAGE NAVIGATION =====
    function isAuthenticated() {
      return auth.currentUser !== null;
    }
    
    function getUserFromEmail(email) {
      return EMAIL_TO_USER[email] || null;
    }

    function showPage(page) {
      // Check if authenticated before allowing access to pages
      if (!isAuthenticated()) {
        // User must sign in - show sign in prompt
        alert("Please sign in with Google to access the app.");
        return;
      }

      // Hide all pages
      document.querySelectorAll('.page-content').forEach(el => el.classList.add('hidden'));
      // Show selected page
      document.getElementById(`page-${page}`).classList.remove('hidden');
      
      // Update nav buttons
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('bg-teal-500', 'text-slate-900');
        btn.classList.add('text-gray-400');
      });
      const activeBtn = document.getElementById(`nav-${page}`);
      if (activeBtn) {
        activeBtn.classList.remove('text-gray-400');
        activeBtn.classList.add('bg-teal-500', 'text-slate-900');
      }

      // Store active page
      localStorage.setItem('ao_active_page', page);

      // Refresh bracket if showing bracket page
      if (page === 'bracket') {
        // Initialize Round 1 if needed
        initializeRound1Matchups();
        refreshBracket();
      }
      // Refresh teams if showing teams page
      if (page === 'teams') {
        refreshTeams();
      }
      // Refresh trades if showing trades page
      if (page === 'trades') {
        refreshTrades();
      }
    }

    // ===== BRACKET PAGE LOGIC =====
    const bracketRoundSelect = document.getElementById("bracket-round-select");
    const bracketContainer = document.getElementById("bracket-container");

    bracketRoundSelect.addEventListener("change", () => {
      refreshBracket();
    });

    // Initialize Round 1 matchups from basePlayers (consecutive pairs)
    function initializeRound1Matchups() {
      db.ref("/bracket/round1").once("value", snap => {
        if (snap.exists() && Object.keys(snap.val()).length > 0) {
          return; // Already initialized
        }

        const matchups = {};
        // Create matchups by pairing consecutive players (0-1, 2-3, 4-5, etc.)
        for (let i = 0; i < basePlayers.length; i += 2) {
          const player1 = basePlayers[i];
          const player2 = basePlayers[i + 1];
          if (player1 && player2) {
            const matchNum = Math.floor(i / 2) + 1;
            matchups[matchNum] = {
              player1Id: player1.id,
              player2Id: player2.id,
              winnerId: null
            };
          }
        }
        db.ref("/bracket/round1").set(matchups);
      });
    }

    // Generate next round matchups based on winners from previous round
    function generateNextRoundMatchups(currentRound) {
      if (currentRound >= 7) return; // Final round, no next round

      const nextRound = currentRound + 1;
      
      db.ref(`/bracket/round${currentRound}`).once("value", snap => {
        const matchups = snap.val() || {};
        const matchupKeys = Object.keys(matchups).map(k => parseInt(k)).sort((a, b) => a - b);
        
        // Get existing next round matchups to preserve what's already there
        db.ref(`/bracket/round${nextRound}`).once("value", nextSnap => {
          const existingNextMatchups = nextSnap.val() || {};
          
          // Generate matchups: winner of match 1 vs winner of match 2, match 3 vs match 4, etc.
          // Update/create matchups as pairs become available
          let nextMatchNum = 1;
          
          for (let i = 0; i < matchupKeys.length; i += 2) {
            const match1Key = matchupKeys[i];
            const match2Key = matchupKeys[i + 1];
            
            if (match1Key && match2Key && matchups[match1Key].winnerId && matchups[match2Key].winnerId) {
              // This pair is ready - create or update the next round matchup
              existingNextMatchups[nextMatchNum] = {
                player1Id: matchups[match1Key].winnerId,
                player2Id: matchups[match2Key].winnerId,
                winnerId: existingNextMatchups[nextMatchNum]?.winnerId || null
              };
              nextMatchNum++;
            }
          }
          
          // Save all next round matchups (both newly created and existing ones)
          if (Object.keys(existingNextMatchups).length > 0) {
            db.ref(`/bracket/round${nextRound}`).set(existingNextMatchups);
          }
        });
      });
    }

    function refreshBracket() {
      // Initialize Round 1 matchups if needed
      if (parseInt(bracketRoundSelect.value) === 1) {
        initializeRound1Matchups();
      }

      // Get current data snapshot
      db.ref("/").once("value", snap => {
        const data = snap.val();
        if (!data) {
          bracketContainer.innerHTML = "<div class='text-gray-400'>No data available. Please start the draft first.</div>";
          return;
        }

        const players = data.players || [];
        const users = data.users || {};
        const round = parseInt(bracketRoundSelect.value);
        const pointsForRound = ROUND_POINTS[round];
        const getDisplayName = (id) => (users[id]?.teamName || id || "");

        // Get matchups for this round from Firebase
        db.ref(`/bracket/round${round}`).once("value", matchSnap => {
          const matchups = matchSnap.val() || {};
          const matchupKeys = Object.keys(matchups).map(k => parseInt(k)).sort((a, b) => a - b);
          
          bracketContainer.innerHTML = "";

          if (matchupKeys.length === 0) {
            // Filter players based on round progression
            // For Round 1: Show all drafted players
            // For Round N (N > 1): Only show players who have won Round N-1 (and all previous rounds)
            let eligiblePlayers = players.filter(p => p.owner);
            
            if (round > 1) {
              eligiblePlayers = eligiblePlayers.filter(p => {
                const roundsWon = p.roundsWon || [];
                // Player must have won all rounds from 1 to (round - 1)
                for (let r = 1; r < round; r++) {
                  if (!roundsWon.includes(r)) {
                    return false;
                  }
                }
                return true;
              });
            }
            
            // No matchups defined - show message with option to view eligible players
            bracketContainer.innerHTML = `
              <div class="text-center py-8 text-gray-400">
                <p class="mb-4">No matchups defined for Round ${round}.</p>
                <p class="text-xs mb-4">Click on players below to mark them as winners of Round ${round} (${pointsForRound} pts).</p>
                <p class="text-xs text-teal-400 mb-4">${round === 1 ? 'All drafted players are eligible for Round 1.' : 'Only players who won Round ' + (round - 1) + ' are shown below.'}</p>
              </div>
              ${eligiblePlayers.length === 0 ? `
                <div class="text-center py-8 text-gray-500">
                  <p>No eligible players for Round ${round}.</p>
                  <p class="text-xs mt-2">Players must win all previous rounds to advance.</p>
                </div>
              ` : `
              <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 mt-6">
                ${eligiblePlayers.map(p => {
                  const seedText = p.seed ? `[${p.seed}]` : '';
                  const roundsWon = p.roundsWon || [];
                  const hasWonThisRound = roundsWon.includes(round);
                  return `
                    <div 
                      onclick="selectBracketWinnerDirect(${p.id}, ${round})" 
                      class="p-3 rounded cursor-pointer transition ${hasWonThisRound ? 'bg-teal-900 border border-teal-500' : 'bg-gray-900 hover:bg-gray-800 border border-gray-700'}"
                    >
                      <div class="font-bold ${hasWonThisRound ? 'text-teal-400' : 'text-white'}">
                        ${seedText} ${p.name}
                      </div>
                      <div class="text-[10px] text-gray-400 mt-1">${getDisplayName(p.owner)}</div>
                      ${hasWonThisRound ? '<div class="text-[10px] text-teal-400 mt-1">✓ Won Round ' + round + '</div>' : ''}
                      ${roundsWon.length > 0 && !hasWonThisRound ? '<div class="text-[10px] text-gray-500 mt-1">Rounds won: ' + roundsWon.join(', ') + '</div>' : ''}
                    </div>
                  `;
                }).join('')}
              </div>
              `}
            `;
          } else {
            // Display existing matchups
            // Filter out matchups where players are no longer eligible (haven't won previous rounds)
            const validMatchups = matchupKeys.filter(matchKey => {
              const matchup = matchups[matchKey];
              const player1 = players.find(p => p.id === matchup.player1Id);
              const player2 = players.find(p => p.id === matchup.player2Id);
              
              if (!player1 || !player2) return false;
              
              // Both players must be eligible for this round
              if (round > 1) {
                const checkEligibility = (p) => {
                  const roundsWon = p.roundsWon || [];
                  for (let r = 1; r < round; r++) {
                    if (!roundsWon.includes(r)) return false;
                  }
                  return true;
                };
                return checkEligibility(player1) && checkEligibility(player2);
              }
              return true;
            });
            
            // Display matchups in a grid layout
            const matchesContainer = document.createElement("div");
            matchesContainer.className = "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4";
            
            validMatchups.forEach((matchKey) => {
              const matchup = matchups[matchKey];
              const player1 = players.find(p => p.id === matchup.player1Id);
              const player2 = players.find(p => p.id === matchup.player2Id);
              const winnerId = matchup.winnerId;

              if (!player1 || !player2) return;

              // Check eligibility for players in this round
              const player1Eligible = round === 1 || (player1.roundsWon || []).includes(round - 1);
              const player2Eligible = round === 1 || (player2.roundsWon || []).includes(round - 1);

              if (!player1Eligible || !player2Eligible) return;

              const player1Seed = player1.seed ? `[${player1.seed}]` : '';
              const player2Seed = player2.seed ? `[${player2.seed}]` : '';
              
              const isPlayer1Winner = winnerId === player1.id;
              const isPlayer2Winner = winnerId === player2.id;
              const isMatchComplete = !!winnerId;

              const matchDiv = document.createElement("div");
              matchDiv.className = "sleeper-card rounded-lg p-4 border " + (isMatchComplete ? "border-teal-500" : "border-gray-700");
              
              matchDiv.innerHTML = `
                <div class="text-xs text-gray-500 mb-3 flex justify-between items-center">
                  <span>Match ${matchKey} • Round ${round}</span>
                  <span class="text-teal-400 font-bold">${pointsForRound} pts</span>
                </div>
                <div class="space-y-2">
                  <div 
                    onclick="selectBracketWinner('${matchKey}', ${player1.id}, ${round})" 
                    class="p-3 rounded cursor-pointer transition ${isPlayer1Winner ? 'bg-teal-900 border border-teal-500' : 'bg-gray-900 hover:bg-gray-800 border border-gray-700'}"
                  >
                    <div class="flex justify-between items-center">
                      <span class="font-bold ${isPlayer1Winner ? 'text-teal-400' : 'text-white'}">
                        ${player1Seed} ${player1.name}
                      </span>
                      ${isPlayer1Winner ? '<span class="text-teal-400 text-xs font-bold">✓ WINNER</span>' : '<span class="text-xs text-gray-500">Click to win</span>'}
                    </div>
                    ${player1.owner ? `<div class="text-[10px] text-gray-400 mt-1">${getDisplayName(player1.owner)}</div>` : '<div class="text-[10px] text-gray-500 mt-1">Undrafted</div>'}
                  </div>
                  <div class="text-center text-xs text-gray-500 font-bold">vs</div>
                  <div 
                    onclick="selectBracketWinner('${matchKey}', ${player2.id}, ${round})" 
                    class="p-3 rounded cursor-pointer transition ${isPlayer2Winner ? 'bg-teal-900 border border-teal-500' : 'bg-gray-900 hover:bg-gray-800 border border-gray-700'}"
                  >
                    <div class="flex justify-between items-center">
                      <span class="font-bold ${isPlayer2Winner ? 'text-teal-400' : 'text-white'}">
                        ${player2Seed} ${player2.name}
                      </span>
                      ${isPlayer2Winner ? '<span class="text-teal-400 text-xs font-bold">✓ WINNER</span>' : '<span class="text-xs text-gray-500">Click to win</span>'}
                    </div>
                    ${player2.owner ? `<div class="text-[10px] text-gray-400 mt-1">${getDisplayName(player2.owner)}</div>` : '<div class="text-[10px] text-gray-500 mt-1">Undrafted</div>'}
                  </div>
                </div>
              `;
              
              matchesContainer.appendChild(matchDiv);
            });
            
            bracketContainer.appendChild(matchesContainer);
          }
        });
      });
    }

    function selectBracketWinner(matchKey, playerId, round) {
      // First, get the current matchup to check if there's a previous winner
      db.ref(`/bracket/round${round}/${matchKey}`).once("value", snap => {
        const currentMatchup = snap.val();
        const previousWinnerId = currentMatchup?.winnerId;
        
        // === NEW LOGIC: DESELECT IF ALREADY SELECTED ===
        if (previousWinnerId === playerId) {
            // 1. Remove points and win count
            removeWinFromPlayer(playerId, round);
            // 2. Clear winner in the bracket DB
            db.ref(`/bracket/round${round}/${matchKey}`).update({ winnerId: null });
            
            // 3. Un-mark the opponent as eliminated (they're back in)
            const opponentId = currentMatchup.player1Id === playerId ? currentMatchup.player2Id : currentMatchup.player1Id;
            if (opponentId) {
              markPlayerEliminated(opponentId, false);
            }
            
            setTimeout(refreshBracket, 200);
            return; // Stop here
        }
        // ===============================================

        // Determine the opponent (loser) for the new winner
        const opponentId = currentMatchup.player1Id === playerId ? currentMatchup.player2Id : currentMatchup.player1Id;

        // Standard logic: Switching winner from Player A to Player B
        if (previousWinnerId && previousWinnerId !== playerId) {
          removeWinFromPlayer(previousWinnerId, round);
          // Un-mark the previous opponent (old winner's opponent) as eliminated
          const previousOpponentId = currentMatchup.player1Id === previousWinnerId ? currentMatchup.player2Id : currentMatchup.player1Id;
          if (previousOpponentId) {
            markPlayerEliminated(previousOpponentId, false);
          }
        }
        
        // Update the matchup with the new winner
        db.ref(`/bracket/round${round}/${matchKey}`).transaction(matchup => {
          if (!matchup) return matchup;
          matchup.winnerId = playerId;
          return matchup;
        });

        // Record the win for scoring
        recordWinForPlayer(playerId, round, previousWinnerId === playerId);
        
        // Mark the opponent as eliminated
        if (opponentId) {
          markPlayerEliminated(opponentId, true, round);
        }
        
        // Generate next round matchups
        setTimeout(() => {
          generateNextRoundMatchups(round);
          refreshBracket();
        }, 200);
      });
    }

    function selectBracketWinnerDirect(playerId, round) {
      // Check if player has already won this round to determine if we add or remove
      db.ref("/").once("value", snap => {
          const data = snap.val();
          if (!data || !data.players) return;
          
          const player = data.players.find(p => p.id === playerId);
          if (!player) return;
          
          const roundsWon = player.roundsWon || [];
          
          if (roundsWon.includes(round)) {
              // Player already won -> DESELECT (Remove win)
              removeWinFromPlayer(playerId, round);
          } else {
              // Player hasn't won yet -> SELECT (Add win)
              recordWinForPlayer(playerId, round);
          }
          setTimeout(refreshBracket, 100);
      });
    }

    function removeWinFromPlayer(playerId, round) {
      const pointsToRemove = ROUND_POINTS[round] || 0;
      db.ref("/").transaction(data => {
        if (!data || !data.players || !data.users) return data;

        const players = data.players;
        const users = data.users;

        const pIndex = players.findIndex(p => p.id === playerId);
        if (pIndex === -1) return data;

        // Remove the round from roundsWon array
        if (players[pIndex].roundsWon) {
          players[pIndex].roundsWon = players[pIndex].roundsWon.filter(r => r !== round);
        }

        // Update Player Stats - subtract points and wins
        players[pIndex].totalWins = Math.max(0, (players[pIndex].totalWins || 0) - 1);
        players[pIndex].points = Math.max(0, (players[pIndex].points || 0) - pointsToRemove);

        // Update Owner Stats (if owned) - subtract points
        if (players[pIndex].owner) {
          const owner = players[pIndex].owner;
          users[owner].score = Math.max(0, (users[owner].score || 0) - pointsToRemove);
        }

        data.players = players;
        data.users = users;
        return data;
      });
    }

    function markPlayerEliminated(playerId, eliminated, round = null) {
      db.ref("/").transaction(data => {
        if (!data || !data.players) return data;

        const players = data.players;
        const pIndex = players.findIndex(p => p.id === playerId);
        if (pIndex === -1) return data;

        if (eliminated) {
          players[pIndex].eliminated = true;
          if (round) {
            players[pIndex].eliminatedRound = round;
          }
        } else {
          players[pIndex].eliminated = false;
          players[pIndex].eliminatedRound = null;
        }

        data.players = players;
        return data;
      });
    }

    function recordWinForPlayer(playerId, round, isAlreadyWinner = false) {
      const pointsToAdd = ROUND_POINTS[round] || 0;
      db.ref("/").transaction(data => {
        if (!data || !data.players || !data.users) return data;

        const players = data.players;
        const users = data.users;

        const pIndex = players.findIndex(p => p.id === playerId);
        if (pIndex === -1) return data;

        // Track which rounds this player has won
        if (!players[pIndex].roundsWon) players[pIndex].roundsWon = [];
        // Only add if not already recorded for this round (avoid duplicates)
        if (!players[pIndex].roundsWon.includes(round)) {
          players[pIndex].roundsWon.push(round);
          players[pIndex].roundsWon.sort((a, b) => a - b); // Keep sorted
          
          // Only increment wins and add points if this is a new win
          if (!isAlreadyWinner) {
            // Update Player Stats
            players[pIndex].totalWins = (players[pIndex].totalWins || 0) + 1;
            players[pIndex].points = (players[pIndex].points || 0) + pointsToAdd;

            // Update Owner Stats (if owned)
            if (players[pIndex].owner) {
              const owner = players[pIndex].owner;
              users[owner].score = (users[owner].score || 0) + pointsToAdd;
            }
          }
        }

        data.players = players;
        data.users = users;
        return data;
      });
    }

    // Calculate maximum remaining points for a user based on their active players
    function calculateMaxRemainingPoints(user, allPlayers, bracketData) {
      if (!user.picks || user.picks.length === 0) return 0;

      // 1. Identify User's Active Players and determine their elimination status by round
      const playerStatus = {}; // { playerId: { eliminatedInRound: null or round number } }
      
      user.picks.forEach(playerId => {
        const player = allPlayers.find(p => p.id === playerId);
        if (!player) return;

        let eliminatedInRound = null;
        
        // Check bracket data to see if/when player was eliminated
        if (bracketData) {
          for (let r = 1; r <= 7; r++) {
            const roundKey = `round${r}`;
            if (!bracketData[roundKey]) continue;
            
            Object.values(bracketData[roundKey]).forEach(match => {
              if (match.winnerId) {
                // If match is over, and player was in it but didn't win -> eliminated in this round
                if ((match.player1Id === playerId || match.player2Id === playerId) && match.winnerId !== playerId) {
                  eliminatedInRound = r;
                }
              }
            });
          }
        }
        
        playerStatus[playerId] = { 
          player: player,
          eliminatedInRound: eliminatedInRound
        };
      });

      // 2. Calculate which bracket slots each active player can reach in each round
      // Round structure: R1 has 64 matches (1-64), R2 has 32 matches (1-32), ..., R7 has 1 match (1)
      // A player with ID maps to a match slot: ceil(ID / 2^round)
      
      let maxRemaining = 0;
      
      // For each round 1-7
      for (let round = 1; round <= 7; round++) {
        const pointsForRound = ROUND_POINTS[round];
        const totalMatchesInRound = Math.floor(128 / Math.pow(2, round)); // 64, 32, 16, 8, 4, 2, 1
        
        // Track which match slots could be won by user's players
        const matchSlotsWithContenders = new Set();
        
        // For each of user's players
        Object.values(playerStatus).forEach(({ player, eliminatedInRound }) => {
          // Skip if player was eliminated before this round
          if (eliminatedInRound !== null && eliminatedInRound < round) {
            return;
          }
          
          // Calculate which match slot this player is in for this round
          const matchSlot = Math.ceil(player.id / Math.pow(2, round));
          
          // Only count if match slot is valid and player could still win this round
          if (matchSlot >= 1 && matchSlot <= totalMatchesInRound) {
            // Check if this match is already decided (points already banked)
            const roundKey = `round${round}`;
            const existingMatch = bracketData && bracketData[roundKey] && bracketData[roundKey][matchSlot];
            
            if (!existingMatch || !existingMatch.winnerId) {
              // Match not decided yet, player can potentially win it
              matchSlotsWithContenders.add(matchSlot);
            }
          }
        });
        
        // Add points for each match slot with a contender
        // Note: If multiple players from same team are in same match slot, only count once
        // (this is already handled by using a Set)
        maxRemaining += matchSlotsWithContenders.size * pointsForRound;
      }

      return maxRemaining;
    }

    // UPDATE THIS FUNCTION
    function refreshTeams() {
      // Fetch main data and bracket data separately
      Promise.all([
        db.ref("/").once("value"),
        db.ref("/bracket").once("value")
      ]).then(([mainSnap, bracketSnap]) => {
        const data = mainSnap.val();
        if (!data) {
          teamsContainer.innerHTML = "<div class='text-gray-400'>No data available.</div>";
          return;
        }

        const players = data.players || [];
        const users = data.users || {};
        const bracket = bracketSnap.val() || {};

        teamsContainer.innerHTML = "";

        // Update team name editor UI for the signed-in user
        const editor = document.getElementById("team-name-editor");
        if (editor && teamNameInput && teamNameSaveBtn) {
          if (isAuthenticated() && currentUser) {
            const currentTeamName = users[currentUser]?.teamName || currentUser;
            teamNameInput.value = currentTeamName;
            teamNameInput.disabled = false;
            teamNameSaveBtn.disabled = false;
            editor.classList.remove("hidden");
          } else {
            editor.classList.add("hidden");
          }
        }

        // Show/hide trade mode toggle
        const tradeToggle = document.getElementById("trade-mode-toggle");
        if (tradeToggle && isAuthenticated() && currentUser) {
          if (!tradeMode) {
            // Show "Enter Trade Mode" button
            tradeToggle.innerHTML = `
              <div class="flex items-center justify-between">
                <div>
                  <h3 class="text-sm font-bold uppercase tracking-widest text-teal-400 mb-1">Trading</h3>
                  <p class="text-[10px] text-gray-400">Select players from your team and another team to create a trade</p>
                </div>
                <button
                  onclick="window.toggleTradeMode()"
                  class="btn-main px-4 py-2 rounded text-[11px] uppercase tracking-widest"
                >
                  Enter Trade Mode
                </button>
              </div>
            `;
            tradeToggle.classList.remove("hidden");
          } else {
            // Show trade mode UI
            tradeToggle.innerHTML = `
              <div class="flex items-center justify-between">
                <div>
                  <h3 class="text-sm font-bold uppercase tracking-widest text-teal-400 mb-1">Trade Mode</h3>
                  <p class="text-[10px] text-gray-400">Select players from your team and another team to create a trade</p>
                </div>
                <button
                  onclick="window.toggleTradeMode()"
                  class="btn-main px-4 py-2 rounded text-[11px] uppercase tracking-widest"
                >
                  Exit Trade Mode
                </button>
              </div>
              <div id="trade-selection-summary" class="mt-4 p-3 bg-gray-800 rounded border border-gray-700 hidden">
                <div class="text-xs text-gray-400 mb-2">Trade Summary:</div>
                <div class="flex gap-4 text-sm">
                  <div>
                    <span class="text-teal-400 font-bold">You Give:</span>
                    <div id="my-trade-players" class="text-gray-300 mt-1"></div>
                  </div>
                  <div>
                    <span class="text-teal-400 font-bold">You Receive:</span>
                    <div id="their-trade-players" class="text-gray-300 mt-1"></div>
                  </div>
                </div>
                <div class="mt-3 flex gap-2">
                  <select id="trade-target-team" class="bg-gray-700 border border-gray-600 text-sm rounded-lg p-2 flex-1">
                    <option value="">Select team to trade with...</option>
                  </select>
                  <button
                    onclick="window.confirmTrade()"
                    id="confirm-trade-btn"
                    class="btn-main px-4 py-2 rounded text-[11px] uppercase tracking-widest disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled
                  >
                    Confirm Trade
                  </button>
                </div>
              </div>
            `;
            tradeToggle.classList.remove("hidden");
            // Update summary after a brief delay to ensure DOM is ready
            setTimeout(() => updateTradeSummary(), 100);
          }
        } else if (tradeToggle) {
          tradeToggle.classList.add("hidden");
        }

        // Always compute team score as the sum of player points to avoid drift
        const computeTeamScore = (owner) => {
          return players
            .filter(p => p.owner === owner)
            .reduce((sum, p) => sum + (p.points || 0), 0);
        };

        // Sort users by score descending
        const sortedUsers = USERS.slice().sort((a, b) => {
                  const scoreA = computeTeamScore(a);
                  const scoreB = computeTeamScore(b);
                  return scoreB - scoreA;
        });

        sortedUsers.forEach((u, idx) => {
          const user = users[u] || { picks: [], score: 0 };
          const pickedPlayers = players.filter(p => p.owner === u).sort((a, b) => (b.points || 0) - (a.points || 0));
          const isViewing = currentUser === u;
          const displayName = users[u]?.teamName || u;
          const activePlayers = pickedPlayers.filter(p => !p.eliminated);

          // Compute displayed score from player points (source of truth)
          const computedScore = pickedPlayers.reduce((sum, p) => sum + (p.points || 0), 0);

          // Calculate Remaining Points
          const remaining = calculateMaxRemainingPoints(user, players, bracket);
          const remainingDisplay = (isNaN(remaining) || remaining === null || remaining === undefined) ? 0 : remaining;

          const div = document.createElement("div");
          div.className = `sleeper-card rounded-xl p-4 border ${isViewing ? 'border-teal-500' : 'border-gray-700'}`;
          
          div.innerHTML = `
            <div class="flex justify-between items-start mb-4">
              <div>
                <div class="text-lg font-bold ${isViewing ? 'text-teal-400' : 'text-white'}">
                ${idx === 0 ? '🥇 ' : idx === 1 ? '🥈 ' : idx === 2 ? '🥉 ' : ''}${displayName}
                ${tradeMode && isViewing ? '<span class="text-xs text-yellow-400 ml-2">(Trade Mode - Select Players)</span>' : ''}
                </div>
              <div class="text-xs text-gray-400 mt-1 flex gap-2">
                 <span>${activePlayers.length} not eliminated</span>
              </div>
              </div>
              <div class="text-right">
                <div class="font-mono text-2xl font-bold text-teal-400">${computedScore.toFixed(3)}</div>
                <div class="text-[10px] text-gray-500">
                    + ${remainingDisplay.toFixed(2)} max rem
                </div>
              </div>
            </div>
            <div class="space-y-2 max-h-96 overflow-y-auto">
              ${pickedPlayers.length
                ? pickedPlayers.map(pl => {
                    const seedText = pl.seed ? `[${pl.seed}] ` : '';
                    const pointsText = pl.points && pl.points > 0 ? `<span class="text-teal-400">${pl.points.toFixed(2)} pts</span>` : '<span class="text-gray-500">0 pts</span>';
                    const isEliminated = pl.eliminated || false;
                    const eliminatedClass = isEliminated ? 'opacity-40 line-through' : '';
                    const eliminatedBadge = isEliminated ? '<div class="text-[10px] text-red-400 font-bold">ELIMINATED</div>' : '';
                    
                    // Trade mode checkbox for my team
                    let tradeCheckbox = '';
                    if (tradeMode && isViewing && !isEliminated) {
                      const isSelected = selectedMyPlayers.has(pl.id);
                      tradeCheckbox = `
                        <input 
                          type="checkbox" 
                          ${isSelected ? 'checked' : ''} 
                          data-player-id="${pl.id}"
                          onchange="if(window.selectMyPlayer) { window.selectMyPlayer(${pl.id}); }"
                          onclick="event.stopPropagation()"
                          class="w-4 h-4 text-teal-600 bg-gray-700 border-gray-600 rounded focus:ring-teal-500 cursor-pointer"
                          style="min-width: 16px; min-height: 16px;"
                        />
                      `;
                    }
                    
                    // Trade mode checkbox for other teams
                    if (tradeMode && !isViewing && !isEliminated) {
                      const isSelected = selectedTheirPlayers.has(pl.id);
                      // Escape single quotes in team owner name
                      const teamOwnerEscaped = String(u).replace(/'/g, "\\'");
                      tradeCheckbox = `
                        <input 
                          type="checkbox" 
                          ${isSelected ? 'checked' : ''} 
                          data-team-owner="${u}"
                          data-player-id="${pl.id}"
                          onchange="window.selectTheirPlayer && window.selectTheirPlayer(${pl.id}, '${teamOwnerEscaped}')"
                          onclick="event.stopPropagation()"
                          class="w-4 h-4 text-teal-600 bg-gray-700 border-gray-600 rounded focus:ring-teal-500 cursor-pointer"
                          style="min-width: 16px; min-height: 16px;"
                        />
                      `;
                    }

                    return `
                      <div class="flex justify-between items-center p-2 bg-gray-900 rounded border ${isEliminated ? 'border-red-700' : 'border-gray-700'} ${eliminatedClass}">
                        <div class="flex items-center gap-2 flex-1">
                          ${tradeCheckbox}
                          <div class="flex-1">
                            <div class="text-sm font-bold">${seedText}${pl.name}</div>
                            <div class="text-[10px] text-gray-400">Wins: ${pl.totalWins || 0}</div>
                            ${eliminatedBadge}
                          </div>
                        </div>
                        <div class="text-xs">${pointsText}</div>
                      </div>
                    `;
                  }).join("")
                : `<div class="text-center py-4 text-gray-500 text-sm">No players drafted</div>`
              }
            </div>
          `;
          
          teamsContainer.appendChild(div);
        });
      }).catch(error => {
        console.error("Error loading teams data:", error);
        teamsContainer.innerHTML = "<div class='text-gray-400'>Error loading data.</div>";
      });
    }

    // ===== AUTHENTICATION =====
    // Update auth UI based on authentication state and set currentUser from email
    function updateAuthUI(user) {
      const signInBtn = document.getElementById("sign-in-btn");
      const userInfo = document.getElementById("user-info");
      const userEmail = document.getElementById("user-email");
      
      if (user) {
        // User is signed in - map email to User number
        const mappedUser = getUserFromEmail(user.email);
        if (mappedUser) {
          currentUser = mappedUser;
          localStorage.setItem("ao_user", mappedUser);
          console.log("User signed in:", user.email, "→", mappedUser);
        } else {
          console.warn("Email not in authorized list:", user.email);
          alert("Your email (" + user.email + ") is not authorized. Please contact administrator.");
          auth.signOut();
          return;
        }
        
        // Update UI
        if (signInBtn) signInBtn.style.display = "none";
        if (userInfo) userInfo.classList.remove("hidden");
        if (userEmail) userEmail.textContent = user.email;
      } else {
        // User is signed out
        currentUser = null;
        localStorage.removeItem("ao_user");
        
        if (signInBtn) signInBtn.style.display = "block";
        if (userInfo) userInfo.classList.add("hidden");
        if (userEmail) userEmail.textContent = "";
        console.log("User signed out");
      }
    }
    
    // Listen for auth state changes
    auth.onAuthStateChanged((user) => {
      updateAuthUI(user);
      // Refresh teams so name editor & display update after auth change
      refreshTeams();
    });
    
    // Save team name for the current signed-in user
    window.saveTeamName = function() {
      if (!isAuthenticated() || !currentUser) {
        alert("Please sign in to edit your team name.");
        return;
      }
      if (!teamNameInput) return;
      const newName = teamNameInput.value.trim() || currentUser;
      db.ref(`/users/${currentUser}/teamName`).set(newName)
        .then(() => {
          refreshTeams();
        })
        .catch((error) => {
          console.error("Failed to save team name:", error);
          alert("Failed to save team name: " + error.message);
        });
    };

    // Login function for Firebase Authentication (using compat mode)
    window.loginAndSave = function() {
      auth.signInWithPopup(provider)
        .then((result) => {
          // The user is now signed in!
          const user = result.user;
          
          // UI and currentUser will be updated automatically by onAuthStateChanged
          // Refresh the current page to ensure everything updates
          const currentPage = localStorage.getItem('ao_active_page') || 'draft';
          if (currentPage === 'bracket') {
            refreshBracket();
          }
        }).catch((error) => {
          console.error("Login failed", error);
          alert("Login failed: " + error.message);
        });
    };
    
    // Sign out function (optional)
    window.signOut = function() {
      auth.signOut()
        .then(() => {
          console.log("User signed out");
          // UI will be updated automatically by onAuthStateChanged
        }).catch((error) => {
          console.error("Sign out failed", error);
        });
    };

    // Make functions available globally
    window.selectBracketWinner = selectBracketWinner;
    window.selectBracketWinnerDirect = selectBracketWinnerDirect;

    // ===== TRADING FUNCTIONALITY =====
    let tradeMode = false;
    let selectedMyPlayers = new Set();
    let selectedTheirPlayers = new Set();
    let selectedTargetTeam = null;

    function toggleTradeMode() {
      tradeMode = !tradeMode;
      selectedMyPlayers.clear();
      selectedTheirPlayers.clear();
      selectedTargetTeam = null;
      
      // Force refresh teams to show/hide checkboxes
      refreshTeams();
    }

    function selectMyPlayer(playerId) {
      if (!tradeMode) return;
      if (selectedMyPlayers.has(playerId)) {
        selectedMyPlayers.delete(playerId);
      } else {
        selectedMyPlayers.add(playerId);
      }
      updateTradeSummary();
      refreshTeams();
    }

    function selectTheirPlayer(playerId, teamOwner) {
      if (!tradeMode) {
        console.log("Trade mode not active");
        return;
      }
      
      console.log("selectTheirPlayer called:", playerId, teamOwner, "Current selectedTargetTeam:", selectedTargetTeam);
      
      // If selecting from a different team, clear previous selection
      if (selectedTargetTeam && selectedTargetTeam !== teamOwner) {
        // Get team name for confirmation
        db.ref("/").once("value", snap => {
          const data = snap.val();
          const users = data?.users || {};
          const teamName = users[teamOwner]?.teamName || teamOwner;
          if (!confirm("You have players selected from another team. Switch to " + teamName + "? This will clear your current selection.")) {
            return;
          }
          selectedTheirPlayers.clear();
          selectedTargetTeam = teamOwner;
          if (selectedTheirPlayers.has(playerId)) {
            selectedTheirPlayers.delete(playerId);
          } else {
            selectedTheirPlayers.add(playerId);
          }
          console.log("After switch - selectedTheirPlayers:", Array.from(selectedTheirPlayers));
          setTimeout(() => {
            updateTradeSummary();
            refreshTeams();
          }, 50);
        });
        return;
      }
      
      selectedTargetTeam = teamOwner;
      
      if (selectedTheirPlayers.has(playerId)) {
        selectedTheirPlayers.delete(playerId);
        // If no players selected from this team, clear target team
        if (selectedTheirPlayers.size === 0) {
          selectedTargetTeam = null;
        }
      } else {
        selectedTheirPlayers.add(playerId);
      }
      
      console.log("After toggle - selectedTheirPlayers:", Array.from(selectedTheirPlayers), "size:", selectedTheirPlayers.size);
      
      // Update summary immediately, then refresh teams
      updateTradeSummary();
      // Refresh teams after a short delay to allow summary to update first
      setTimeout(() => {
        refreshTeams();
      }, 100);
    }

    function updateTradeSummary() {
      console.log("updateTradeSummary called - selectedMyPlayers:", Array.from(selectedMyPlayers), "selectedTheirPlayers:", Array.from(selectedTheirPlayers));
      
      // Use a small delay to ensure DOM is ready
      setTimeout(() => {
        const summaryEl = document.getElementById("trade-selection-summary");
        if (!summaryEl) {
          console.log("Summary element not found, retrying...");
          setTimeout(updateTradeSummary, 100);
          return;
        }
        
        const myPlayersEl = document.getElementById("my-trade-players");
        const theirPlayersEl = document.getElementById("their-trade-players");
        const confirmBtn = document.getElementById("confirm-trade-btn");
        const targetSelect = document.getElementById("trade-target-team");
        
        if (!myPlayersEl || !theirPlayersEl || !confirmBtn || !targetSelect) {
          console.log("Trade summary elements not found, retrying...");
          setTimeout(updateTradeSummary, 100);
          return;
        }
        
        if (selectedMyPlayers.size === 0 && selectedTheirPlayers.size === 0) {
          summaryEl.classList.add("hidden");
          return;
        }
        
        summaryEl.classList.remove("hidden");
        
        // Get player names
        db.ref("/").once("value", snap => {
          const data = snap.val();
          if (!data || !data.players) {
            console.log("No data or players found");
            return;
          }
          
          const players = data.players;
          const users = data.users || {};
          const myPlayerNames = Array.from(selectedMyPlayers)
            .map(id => {
              const p = players.find(pl => pl.id === id);
              return p ? p.name : `Player ${id}`;
            });
          const theirPlayerNames = Array.from(selectedTheirPlayers)
            .map(id => {
              const p = players.find(pl => pl.id === id);
              return p ? p.name : `Player ${id}`;
            });
          
          console.log("Updating display - myPlayerNames:", myPlayerNames, "theirPlayerNames:", theirPlayerNames);
          
          myPlayersEl.textContent = myPlayerNames.length > 0 ? myPlayerNames.join(", ") : "None";
          theirPlayersEl.textContent = theirPlayerNames.length > 0 ? theirPlayerNames.join(", ") : "None";
        
        // Populate target team dropdown
        targetSelect.innerHTML = '<option value="">Select team to trade with...</option>';
        USERS.forEach(user => {
          if (user !== currentUser) {
            const opt = document.createElement("option");
            opt.value = user;
            opt.textContent = users[user]?.teamName || user;
            if (selectedTargetTeam === user) {
              opt.selected = true;
            }
            targetSelect.appendChild(opt);
          }
        });
        
        // Handle target team selection change
        targetSelect.onchange = function() {
          const newTarget = this.value || null;
          // If switching teams, clear their player selection
          if (newTarget !== selectedTargetTeam) {
            selectedTheirPlayers.clear();
          }
          selectedTargetTeam = newTarget;
          updateTradeSummary();
          refreshTeams();
        };
        
        // Enable confirm button only if both sides have players and target is selected
        const canConfirm = selectedMyPlayers.size > 0 && 
                          selectedTheirPlayers.size > 0 && 
                          selectedTargetTeam !== null;
        confirmBtn.disabled = !canConfirm;
        });
      });
    }

    function confirmTrade() {
      if (!tradeMode || !currentUser) return;
      if (selectedMyPlayers.size === 0 || selectedTheirPlayers.size === 0 || !selectedTargetTeam) {
        alert("Please select players from both teams and select a target team.");
        return;
      }
      
      // Verify all selected players from other team actually belong to selectedTargetTeam
      db.ref("/").once("value", snap => {
        const data = snap.val();
        if (!data || !data.players) return;
        
        const players = data.players;
        const users = data.users || {};
        const invalidPlayers = Array.from(selectedTheirPlayers).filter(playerId => {
          const player = players.find(p => p.id === playerId);
          return !player || player.owner !== selectedTargetTeam;
        });
        
        if (invalidPlayers.length > 0) {
          alert("Some selected players don't belong to the target team. Please refresh and try again.");
          return;
        }
        
        const targetTeamName = users[selectedTargetTeam]?.teamName || selectedTargetTeam;
        if (!confirm(`Confirm trade: You give ${selectedMyPlayers.size} player(s) to ${targetTeamName} in exchange for ${selectedTheirPlayers.size} player(s)?`)) {
          return;
        }
        
        // Create trade object
        const trade = {
          fromUser: currentUser,
          toUser: selectedTargetTeam,
          myPlayers: Array.from(selectedMyPlayers),
          theirPlayers: Array.from(selectedTheirPlayers),
          status: 'pending',
          timestamp: Date.now()
        };
        
        // Save to Firebase
        db.ref("/trades").push(trade)
          .then(() => {
            alert("Trade proposal sent!");
            // Reset trade mode
            toggleTradeMode();
            // Switch to trades page
            showPage('trades');
          })
          .catch(error => {
            console.error("Error creating trade:", error);
            alert("Failed to create trade: " + error.message);
          });
      });
    }

    function acceptTrade(tradeId) {
      db.ref(`/trades/${tradeId}`).once("value", snap => {
        const trade = snap.val();
        if (!trade || trade.status !== 'pending' || trade.toUser !== currentUser) {
          alert("You can only accept trades sent to you.");
          return;
        }
        
        if (!confirm("Accept this trade? This will transfer players between teams.")) {
          return;
        }
        
        // Update player ownerships
        db.ref("/").transaction(data => {
          if (!data || !data.players || !data.users) return data;
          
          const players = data.players;
          const users = data.users;
          
          // Ensure users object has picks arrays
          if (!users[trade.fromUser]) users[trade.fromUser] = { picks: [], score: 0 };
          if (!users[trade.toUser]) users[trade.toUser] = { picks: [], score: 0 };
          if (!users[trade.fromUser].picks) users[trade.fromUser].picks = [];
          if (!users[trade.toUser].picks) users[trade.toUser].picks = [];
          
          // Transfer players from trade.fromUser to trade.toUser (myPlayers)
          trade.myPlayers.forEach(playerId => {
            const pIndex = players.findIndex(p => p.id === playerId);
            if (pIndex !== -1) {
              // Verify player belongs to fromUser before transferring
              if (players[pIndex].owner === trade.fromUser) {
                players[pIndex].owner = trade.toUser;
                // Update user picks arrays
                users[trade.fromUser].picks = users[trade.fromUser].picks.filter(id => id !== playerId);
                if (!users[trade.toUser].picks.includes(playerId)) {
                  users[trade.toUser].picks.push(playerId);
                }
              }
            }
          });
          
          // Transfer players from trade.toUser to trade.fromUser (theirPlayers)
          trade.theirPlayers.forEach(playerId => {
            const pIndex = players.findIndex(p => p.id === playerId);
            if (pIndex !== -1) {
              // Verify player belongs to toUser before transferring
              if (players[pIndex].owner === trade.toUser) {
                players[pIndex].owner = trade.fromUser;
                // Update user picks arrays
                users[trade.toUser].picks = users[trade.toUser].picks.filter(id => id !== playerId);
                if (!users[trade.fromUser].picks.includes(playerId)) {
                  users[trade.fromUser].picks.push(playerId);
                }
              }
            }
          });
          
          data.players = players;
          data.users = users;
          return data;
        }).then(() => {
          // Mark trade as accepted
          db.ref(`/trades/${tradeId}`).update({ status: 'accepted' })
            .then(() => {
              alert("Trade accepted! Players have been transferred.");
              refreshTrades();
              refreshTeams();
            })
            .catch(error => {
              console.error("Error updating trade status:", error);
              alert("Trade was processed but there was an error updating the status.");
            });
        }).catch(error => {
          console.error("Error accepting trade:", error);
          alert("Failed to accept trade: " + error.message);
        });
      });
    }

    function denyTrade(tradeId) {
      db.ref(`/trades/${tradeId}`).once("value", snap => {
        const trade = snap.val();
        if (!trade || trade.status !== 'pending' || trade.toUser !== currentUser) {
          alert("You can only deny trades sent to you.");
          return;
        }
        
        if (!confirm("Deny this trade?")) {
          return;
        }
        
        db.ref(`/trades/${tradeId}`).update({ status: 'denied' })
          .then(() => {
            refreshTrades();
          });
      });
    }

    function refreshTrades() {
      const tradesContainer = document.getElementById("trades-container");
      if (!tradesContainer) return;
      
      db.ref("/").once("value", mainSnap => {
        const mainData = mainSnap.val();
        if (!mainData) {
          tradesContainer.innerHTML = "<div class='text-gray-400'>No data available.</div>";
          return;
        }
        
        const players = mainData.players || [];
        const users = mainData.users || {};
        
        db.ref("/trades").once("value", tradesSnap => {
          const trades = tradesSnap.val() || {};
          const tradeEntries = Object.entries(trades);
          
          if (tradeEntries.length === 0) {
            tradesContainer.innerHTML = "<div class='text-gray-400 text-center py-8'>No trades yet. Go to Teams page to create a trade.</div>";
            return;
          }
          
          // Filter trades relevant to current user
          const relevantTrades = tradeEntries.filter(([id, trade]) => 
            trade.fromUser === currentUser || trade.toUser === currentUser
          );
          
          if (relevantTrades.length === 0) {
            tradesContainer.innerHTML = "<div class='text-gray-400 text-center py-8'>No trades involving your team.</div>";
            return;
          }
          
          tradesContainer.innerHTML = "";
          
          relevantTrades.forEach(([tradeId, trade]) => {
            const isIncoming = trade.toUser === currentUser;
            const isPending = trade.status === 'pending';
            const otherUser = isIncoming ? trade.fromUser : trade.toUser;
            const otherUserName = users[otherUser]?.teamName || otherUser;
            
            // For display: what you receive and what you give
            // For incoming: you receive trade.myPlayers (from sender), you give trade.theirPlayers (to sender)
            // For outgoing: you give trade.myPlayers (to recipient), you receive trade.theirPlayers (from recipient)
            const playersYouReceive = isIncoming ? trade.myPlayers : trade.theirPlayers;
            const playersYouGive = isIncoming ? trade.theirPlayers : trade.myPlayers;
            
            const playersYouReceiveNames = playersYouReceive.map(id => {
              const p = players.find(pl => pl.id === id);
              return p ? p.name : `Player ${id}`;
            });
            const playersYouGiveNames = playersYouGive.map(id => {
              const p = players.find(pl => pl.id === id);
              return p ? p.name : `Player ${id}`;
            });
            
            const statusColor = trade.status === 'accepted' ? 'text-green-400' : 
                               trade.status === 'denied' ? 'text-red-400' : 'text-yellow-400';
            const statusText = trade.status === 'accepted' ? 'ACCEPTED' : 
                              trade.status === 'denied' ? 'DENIED' : 'PENDING';
            
            const tradeDiv = document.createElement("div");
            tradeDiv.className = `sleeper-card rounded-xl p-4 border ${
              isPending && isIncoming ? 'border-yellow-500' : 
              trade.status === 'accepted' ? 'border-green-500' : 
              trade.status === 'denied' ? 'border-red-500' : 
              'border-gray-700'
            }`;
            
            tradeDiv.innerHTML = `
              <div class="flex justify-between items-start mb-4">
                <div>
                  <div class="text-lg font-bold ${isIncoming ? 'text-yellow-400' : 'text-teal-400'}">
                    ${isIncoming ? 'Incoming' : 'Outgoing'} Trade
                  </div>
                  <div class="text-xs text-gray-400 mt-1">
                    ${isIncoming ? 'From' : 'To'}: ${otherUserName}
                  </div>
                </div>
                <div class="text-right">
                  <div class="text-sm font-bold ${statusColor}">${statusText}</div>
                  <div class="text-[10px] text-gray-500 mt-1">
                    ${new Date(trade.timestamp).toLocaleString()}
                  </div>
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <div class="text-xs font-bold text-teal-400 mb-2">You Receive:</div>
                  <div class="space-y-1">
                    ${playersYouReceiveNames.length > 0 ? playersYouReceiveNames.map(name => 
                      `<div class="text-sm p-2 bg-gray-800 rounded border border-gray-700">${name}</div>`
                    ).join('') : '<div class="text-sm text-gray-500">None</div>'}
                  </div>
                </div>
                <div>
                  <div class="text-xs font-bold text-teal-400 mb-2">You Give:</div>
                  <div class="space-y-1">
                    ${playersYouGiveNames.length > 0 ? playersYouGiveNames.map(name => 
                      `<div class="text-sm p-2 bg-gray-800 rounded border border-gray-700">${name}</div>`
                    ).join('') : '<div class="text-sm text-gray-500">None</div>'}
                  </div>
                </div>
              </div>
              ${isPending && isIncoming ? `
                <div class="flex gap-2">
                  <button
                    onclick="acceptTrade('${tradeId}')"
                    class="btn-main px-4 py-2 rounded text-[11px] uppercase tracking-widest flex-1"
                  >
                    Accept
                  </button>
                  <button
                    onclick="denyTrade('${tradeId}')"
                    class="px-4 py-2 rounded text-[11px] uppercase tracking-widest bg-red-600 hover:bg-red-700 text-white flex-1"
                  >
                    Deny
                  </button>
                </div>
              ` : ''}
            `;
            
            tradesContainer.appendChild(tradeDiv);
          });
        });
      });
    }

    // Make trade functions globally available
    window.toggleTradeMode = toggleTradeMode;
    window.selectMyPlayer = selectMyPlayer;
    window.selectTheirPlayer = selectTheirPlayer;
    window.confirmTrade = confirmTrade;
    window.acceptTrade = acceptTrade;
    window.denyTrade = denyTrade;

    // ===== TEAMS PAGE LOGIC =====
    const teamsContainer = document.getElementById("teams-container");

    // Restore user selection and active page
    window.onload = () => {
      // Check if authenticated - auth state will be handled by onAuthStateChanged
      // Show saved page if authenticated, otherwise user needs to sign in
      if (isAuthenticated() && currentUser) {
        const savedPage = localStorage.getItem('ao_active_page') || 'draft';
        showPage(savedPage);
      }
      // If not authenticated, showPage will handle prompting for sign-in
    };
  </script>
</body>
</html>